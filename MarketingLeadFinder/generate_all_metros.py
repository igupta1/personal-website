#!/usr/bin/env python3
"""
Pre-generate leads for all metro areas and upload to cache.

This script runs the lead finder for each metro area and uploads
the results to the website cache so users get instant results.

Usage:
    python generate_all_metros.py                     # Generate all metros
    python generate_all_metros.py --metro los_angeles # Single metro by key
    python generate_all_metros.py --metro "Greater Boston Area"  # Single metro by display name
    python generate_all_metros.py --dry-run           # Generate without uploading
    python generate_all_metros.py --list              # List all available metros

Requirements:
    - Set LEADS_UPLOAD_API_KEY environment variable
    - Set GOOGLE_GEMINI_API_KEY environment variable
"""

import argparse
import asyncio
import csv
import os
import re
import sys
from datetime import datetime
from typing import List, Dict, Any

import requests
from dotenv import load_dotenv

from main import MarketingLeadFinder, OUTPUT_CSV
from metro_config import METRO_CONFIGS, get_metro_config, get_all_metro_keys

load_dotenv()

# Configuration
API_URL = "https://www.ishaangpta.com/api/upload-leads"
DELAY_BETWEEN_METROS = 30  # seconds


def read_leads_from_csv(filepath: str) -> List[Dict[str, Any]]:
    """Read leads from the CSV file generated by main.py"""
    leads = []

    if not os.path.exists(filepath):
        return leads

    with open(filepath, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            # Skip leads without a contact name AND email
            contact_name = row.get('Contact Name', '').strip()
            contact_email = row.get('Contact Email', '').strip()
            if not contact_name or not contact_email:
                continue

            # Parse name into first/last
            name_parts = contact_name.split(' ', 1)
            first_name = name_parts[0] if name_parts else ''
            last_name = name_parts[1] if len(name_parts) > 1 else ''

            # Convert category
            csv_category = row.get('Category', '')
            if 'â‰¤100' in csv_category or '<=100' in csv_category.lower():
                category = 'small'
            elif '101-250' in csv_category:
                category = 'medium'
            elif '251' in csv_category:
                category = 'large'
            else:
                category = 'small'

            lead = {
                'firstName': first_name,
                'lastName': last_name,
                'title': row.get('Contact Title', ''),
                'companyName': row.get('Company Name', ''),
                'email': contact_email,
                'website': row.get('Website', ''),
                'location': row.get('City/Neighborhood', ''),
                'companySize': row.get('Company Size', ''),
                'category': category,
                'evidence': row.get('Evidence', ''),
                'jobRole': row.get('Job Role', ''),
                'jobLink': row.get('Job Link', '')
            }
            leads.append(lead)

    return leads


def upload_leads(leads: List[Dict], location: str, api_key: str) -> bool:
    """Upload leads to the website API"""
    headers = {
        'Content-Type': 'application/json',
        'X-API-Key': api_key
    }

    payload = {
        'location': location,
        'leads': leads
    }

    try:
        response = requests.post(API_URL, json=payload, headers=headers)
        result = response.json()

        if response.status_code == 200 and result.get('success'):
            return True
        else:
            print(f"    Error: {result.get('error', 'Unknown error')}")
            return False
    except Exception as e:
        print(f"    Upload failed: {e}")
        return False


async def generate_metro(metro_key: str, dry_run: bool = False) -> Dict[str, Any]:
    """Generate leads for a single metro area"""
    config = METRO_CONFIGS[metro_key]

    print(f"\n{'='*60}")
    print(f"Generating leads for: {config.display_name}")
    print(f"Key: {metro_key}")
    print(f"{'='*60}")

    result = {
        'metro_key': metro_key,
        'display_name': config.display_name,
        'leads_count': 0,
        'small_count': 0,
        'medium_count': 0,
        'large_count': 0,
        'success': False,
        'error': None
    }

    try:
        # Run the lead finder
        finder = MarketingLeadFinder(config.display_name)
        await finder.run()

        # Read leads from CSV
        leads = read_leads_from_csv(OUTPUT_CSV)
        result['leads_count'] = len(leads)
        result['small_count'] = sum(1 for l in leads if l['category'] == 'small')
        result['medium_count'] = sum(1 for l in leads if l['category'] == 'medium')
        result['large_count'] = sum(1 for l in leads if l['category'] == 'large')

        print(f"\n  Found {len(leads)} leads:")
        print(f"    - Small (<=100): {result['small_count']}")
        print(f"    - Medium (101-250): {result['medium_count']}")
        print(f"    - Large (251+): {result['large_count']}")

        if dry_run:
            print(f"  [DRY RUN] Would upload {len(leads)} leads")
            result['success'] = True
        elif leads:
            api_key = os.getenv('LEADS_UPLOAD_API_KEY')
            if api_key:
                print(f"  Uploading to cache...")
                result['success'] = upload_leads(leads, config.display_name, api_key)
                if result['success']:
                    print(f"  Uploaded successfully!")
            else:
                result['error'] = "LEADS_UPLOAD_API_KEY not set"
                print(f"  Error: {result['error']}")
        else:
            print(f"  No leads to upload")
            result['success'] = True  # Not an error, just no leads found

    except Exception as e:
        result['error'] = str(e)
        print(f"  Error: {e}")

    return result


def list_metros():
    """Print list of all available metros"""
    print("\nAvailable Metro Areas:")
    print("-" * 60)
    for key, config in sorted(METRO_CONFIGS.items()):
        print(f"  {key:20} -> {config.display_name}")
    print("-" * 60)
    print(f"Total: {len(METRO_CONFIGS)} metros\n")


async def main():
    parser = argparse.ArgumentParser(
        description='Generate leads for metro areas and upload to cache',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python generate_all_metros.py                           # Generate all metros
  python generate_all_metros.py --metro los_angeles       # Single metro
  python generate_all_metros.py --metro "Greater Boston Area"
  python generate_all_metros.py --dry-run                 # Test without uploading
  python generate_all_metros.py --list                    # Show available metros
        """
    )
    parser.add_argument('--metro', '-m', help='Specific metro to generate (key or display name)')
    parser.add_argument('--dry-run', '-n', action='store_true', help='Generate without uploading')
    parser.add_argument('--list', '-l', action='store_true', help='List all available metros')
    parser.add_argument('--delay', '-d', type=int, default=DELAY_BETWEEN_METROS,
                        help=f'Delay between metros in seconds (default: {DELAY_BETWEEN_METROS})')
    args = parser.parse_args()

    if args.list:
        list_metros()
        return

    # Check environment
    if not os.getenv('GOOGLE_GEMINI_API_KEY'):
        print("Error: GOOGLE_GEMINI_API_KEY environment variable is not set.")
        sys.exit(1)

    if not args.dry_run and not os.getenv('LEADS_UPLOAD_API_KEY'):
        print("Error: LEADS_UPLOAD_API_KEY environment variable is not set.")
        print("Use --dry-run to test without uploading.")
        sys.exit(1)

    # Determine which metros to process
    if args.metro:
        # Try to find the metro by key or display name
        metro_key = None
        metro_input = args.metro.lower().strip()

        # Check if it's a direct key match
        if metro_input.replace(" ", "_") in METRO_CONFIGS:
            metro_key = metro_input.replace(" ", "_")
        else:
            # Try to find by display name or partial match
            for key, config in METRO_CONFIGS.items():
                if config.display_name.lower() == args.metro.lower():
                    metro_key = key
                    break
                if key in metro_input or metro_input in key:
                    metro_key = key
                    break

        if not metro_key:
            print(f"Error: Unknown metro '{args.metro}'")
            print("Use --list to see available metros.")
            sys.exit(1)

        metros = [metro_key]
    else:
        metros = get_all_metro_keys()

    # Print header
    print("=" * 60)
    print("MARKETING LEAD GENERATOR - BATCH MODE")
    print("=" * 60)
    print(f"Metros to process: {len(metros)}")
    print(f"Dry run: {args.dry_run}")
    print(f"Delay between metros: {args.delay} seconds")
    print(f"Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)

    # Process each metro
    results = []
    for i, metro_key in enumerate(metros):
        result = await generate_metro(metro_key, args.dry_run)
        results.append(result)

        # Wait between metros (except for the last one)
        if i < len(metros) - 1:
            print(f"\nWaiting {args.delay} seconds before next metro...")
            await asyncio.sleep(args.delay)

    # Print summary
    print("\n" + "=" * 60)
    print("GENERATION SUMMARY")
    print("=" * 60)
    print(f"Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("-" * 60)

    total_leads = 0
    successful = 0
    failed = 0

    for r in results:
        status = "OK" if r['success'] else "FAILED"
        if r['success']:
            successful += 1
        else:
            failed += 1
        total_leads += r['leads_count']

        status_str = f"[{status}]"
        print(f"{r['display_name']:35} {r['leads_count']:3} leads {status_str:10}")
        if r['error']:
            print(f"  Error: {r['error']}")

    print("-" * 60)
    print(f"Total: {total_leads} leads across {len(results)} metros")
    print(f"Successful: {successful}, Failed: {failed}")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())
